/**
 Создайте декоратор makeCaching(f), который берет функцию f и возвращает обертку,
 которая кеширует её результаты.

 В этой задаче функция f имеет только один аргумент, и он является числом.

 При первом вызове обертки с определенным аргументом — она вызывает f и запоминает
 значение.
 При втором и последующих вызовах с тем же аргументом возвращается запомненное значение.
 Должно работать так:

 function f(x) {
  return Math.random() * x; // random для удобства тестирования
}

 function makeCaching(f) { /* ваш код }

 f = makeCaching(f);

 var a, b;

 a = f(1);
 b = f(1);
 alert( a == b ); // true (значение закешировано)

 b = f(2);
 alert( a == b ); // false, другой аргумент => другое значение

 */

function func(x) {
    return Math.random() * x;
}

function makeCashing(func) {
    var cash = {};
    return function (x) {
        if (!(x in cash)) {
            cash[x] = func.call(this, x);
        }
        return cash[x];
    }
}

func = makeCashing(func);
var a = func(1);
var b = func(1);
console.log(a == b);
b = func(4);
console.log(a == b);


